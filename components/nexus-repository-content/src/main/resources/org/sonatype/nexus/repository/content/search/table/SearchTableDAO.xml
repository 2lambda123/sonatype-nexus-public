<?xml version="1.0" encoding="UTF-8" ?>
<!--

    Sonatype Nexus (TM) Open Source Version
    Copyright (c) 2008-present Sonatype, Inc.
    All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.

    This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
    which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.

    Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. "Sonatype" and "Sonatype Nexus" are trademarks
    of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
    Eclipse Foundation. All other trademarks are the property of their respective owners.

-->
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.sonatype.nexus.repository.content.search.table.SearchTableDAO">
  <insert id="createSchema" databaseId="PostgreSQL">
    CREATE TABLE IF NOT EXISTS search_components
    (
      repository_id          INTEGER                  NOT NULL,
      component_id           INTEGER                  NOT NULL,
      format                 VARCHAR                  NOT NULL,
      namespace              VARCHAR                  NOT NULL,
      search_component_name  VARCHAR                  NOT NULL,
      component_kind         VARCHAR                  NOT NULL,
      version                VARCHAR                  NOT NULL,
      component_created      TIMESTAMP WITH TIME ZONE NOT NULL,
      search_repository_name VARCHAR(200)             NOT NULL,
      normalised_version     VARCHAR                  NOT NULL,
      prerelease             BOOLEAN                  NOT NULL DEFAULT false,
      keywords                         TSVECTOR,
      md5                              TSVECTOR,
      sha1                             TSVECTOR,
      sha256                           TSVECTOR,
      sha512                           TSVECTOR,
      format_field_values_1            TSVECTOR,
      format_field_values_2            TSVECTOR,
      format_field_values_3            TSVECTOR,
      format_field_values_4            TSVECTOR,
      format_field_values_5            TSVECTOR,
      uploaders                        TSVECTOR,
      uploader_ips                     TSVECTOR,
      paths                            VARCHAR,
      tsvector_paths                   TSVECTOR,
      tsvector_format                  TSVECTOR       NOT NULL,
      tsvector_namespace               TSVECTOR       NOT NULL,
      tsvector_search_component_name   TSVECTOR       NOT NULL,
      tsvector_version                 TSVECTOR       NOT NULL,
      tsvector_search_repository_name  TSVECTOR       NOT NULL,
      last_event_time                  TIMESTAMP      WITH TIME ZONE,
      CONSTRAINT pk_search_components PRIMARY KEY (repository_id, component_id, format)
      );

    CREATE INDEX IF NOT EXISTS idx_search_components_normalised_version ON search_components (normalised_version);
    CREATE INDEX IF NOT EXISTS idx_search_components_namespace ON search_components (namespace);
    CREATE INDEX IF NOT EXISTS idx_search_components_component_name ON search_components (search_component_name);
    CREATE INDEX IF NOT EXISTS idx_search_components_format ON search_components (format);
    CREATE INDEX IF NOT EXISTS idx_search_components_repository_name ON search_components (search_repository_name);
    CREATE INDEX IF NOT EXISTS idx_search_components_prerelease ON search_components (prerelease);
    CREATE INDEX IF NOT EXISTS idx_search_components_keywords ON search_components USING GIN (keywords);
    CREATE INDEX IF NOT EXISTS idx_search_components_md5 ON search_components USING GIN (md5);
    CREATE INDEX IF NOT EXISTS idx_search_components_sha1 ON search_components USING GIN (sha1);
    CREATE INDEX IF NOT EXISTS idx_search_components_sha256 ON search_components USING GIN (sha256);
    CREATE INDEX IF NOT EXISTS idx_search_components_sha512 ON search_components USING GIN (sha512);
    CREATE INDEX IF NOT EXISTS idx_search_components_format_field_values_1 ON search_components USING GIN (format_field_values_1);
    CREATE INDEX IF NOT EXISTS idx_search_components_format_field_values_2 ON search_components USING GIN (format_field_values_2);
    CREATE INDEX IF NOT EXISTS idx_search_components_format_field_values_3 ON search_components USING GIN (format_field_values_3);
    CREATE INDEX IF NOT EXISTS idx_search_components_format_field_values_4 ON search_components USING GIN (format_field_values_4);
    CREATE INDEX IF NOT EXISTS idx_search_components_format_field_values_5 ON search_components USING GIN (format_field_values_5);
    CREATE INDEX IF NOT EXISTS idx_search_components_format_uploaders ON search_components USING GIN (uploaders);
    CREATE INDEX IF NOT EXISTS idx_search_components_format_uploader_ips ON search_components USING GIN (uploader_ips);
    CREATE INDEX IF NOT EXISTS idx_search_components_paths ON search_components (paths);
    CREATE INDEX IF NOT EXISTS idx_search_components_tsvector_paths ON search_components USING GIN (tsvector_paths);
    CREATE INDEX IF NOT EXISTS idx_search_components_tsvector_format ON search_components USING GIN (tsvector_format);
    CREATE INDEX IF NOT EXISTS idx_search_components_tsvector_namespace ON search_components USING GIN (tsvector_namespace);
    CREATE INDEX IF NOT EXISTS idx_search_components_tsvector_search_component_name ON search_components USING GIN (tsvector_search_component_name);
    CREATE INDEX IF NOT EXISTS idx_search_components_tsvector_version ON search_components USING GIN (tsvector_version);
    CREATE INDEX IF NOT EXISTS idx_search_components_tsvector_search_repository_name ON search_components USING GIN (tsvector_search_repository_name);
  </insert>

  <insert id="createSchema" databaseId="H2">
    CREATE TABLE IF NOT EXISTS search_components
    (
    repository_id          INTEGER                  NOT NULL,
    component_id           INTEGER                  NOT NULL,
    format                 VARCHAR                  NOT NULL,
    namespace              VARCHAR                  NOT NULL,
    search_component_name  VARCHAR                  NOT NULL,
    component_kind         VARCHAR                  NOT NULL,
    version                VARCHAR                  NOT NULL,
    component_created      TIMESTAMP WITH TIME ZONE NOT NULL,
    search_repository_name VARCHAR(200)             NOT NULL,
    normalised_version     VARCHAR                  NOT NULL,
    prerelease             BOOLEAN                  NOT NULL DEFAULT false,
    uploaders              VARCHAR,
    uploader_ips           VARCHAR,
    last_event_time        TIMESTAMP WITH TIME ZONE,
    CONSTRAINT pk_search_components PRIMARY KEY (repository_id, component_id, format)
    );

    CREATE INDEX IF NOT EXISTS idx_search_components_normalised_version ON search_components (normalised_version);
    CREATE INDEX IF NOT EXISTS idx_search_components_namespace ON search_components (namespace);
    CREATE INDEX IF NOT EXISTS idx_search_components_component_name ON search_components (search_component_name);
    CREATE INDEX IF NOT EXISTS idx_search_components_format ON search_components (format);
    CREATE INDEX IF NOT EXISTS idx_search_components_repository_name ON search_components (search_repository_name);
    CREATE INDEX IF NOT EXISTS idx_search_components_prerelease ON search_components (prerelease);
    CREATE INDEX IF NOT EXISTS idx_search_components_uploaders ON search_components (uploaders);
    CREATE INDEX IF NOT EXISTS idx_search_components_uploader_ips ON search_components (uploader_ips);
  </insert>

  <sql id="repositoryMatch">
    repository_id = #{repositoryId}
    AND format = #{format}
  </sql>

  <sql id="componentMatch">
    <include refid="repositoryMatch"/>
    AND component_id = #{componentId}
  </sql>

  <sql id="PKMatch">
    <include refid="componentMatch"/>
  </sql>

  <resultMap id="searchTableData" type="org.sonatype.nexus.repository.content.search.table.SearchTableData">
    <id property="repositoryId" column="repository_id" />
    <id property="componentId" column="component_id" />
    <id property="format" column="format" />
    <result property="namespace" column="namespace"/>
    <result property="componentName" column="search_component_name"/>
    <result property="componentKind" column="component_kind"/>
    <result property="version" column="version"/>
    <result property="normalisedVersion" column="normalised_version"/>
    <result property="componentCreated" column="component_created"/>
    <result property="repositoryName" column="search_repository_name"/>
    <result property="prerelease" column="prerelease"/>
  </resultMap>

  <insert id="save" parameterType="SearchTableData" databaseId="PostgreSQL">
    -- Only insert if the component still exists - we achieve this by using the FROM clause below to check the existence of the component
    -- In a multi node setup, as we can't use distributed cooperation for processing a if one node has deleted all the component records for a given repository in response to a
    -- ContentRepositoryDeleted event, for a  then we don't want a delayed update from another node to re-introduce
    -- any of those records.
      INSERT INTO search_components(repository_id, component_id, format, namespace, search_component_name, version,
          search_repository_name, tsvector_format, tsvector_namespace, tsvector_search_component_name,
          tsvector_version, tsvector_search_repository_name, component_kind, normalised_version, prerelease, last_event_time,
          paths, uploaders, uploader_ips, tsvector_paths, keywords, md5, sha1, sha256, sha512, format_field_values_1, format_field_values_2,
          format_field_values_3, format_field_values_4, format_field_values_5, component_created)
        SELECT
           #{repositoryId}, #{componentId}, #{format}, #{namespace}, #{componentName}, #{version}, #{repositoryName},
            to_tsvector('simple', coalesce(#{format}, '')), to_tsvector('simple', coalesce(#{namespace}, '')),
            to_tsvector('simple', coalesce(#{componentName}, '')), to_tsvector('simple', coalesce(#{version}, '')),
            to_tsvector('simple', coalesce(#{repositoryName}, '')),
            #{componentKind}, #{normalisedVersion}, #{prerelease}, #{lastEventTime},
            <include refid="join"><property name="thePaths" value="paths"/></include>,
            <include refid="toTsVector"><property name="tokens" value="uploaders"/></include>,
            <include refid="toTsVector"><property name="tokens" value="uploaderIps"/></include>,
            <include refid="toTsVector"><property name="tokens" value="paths"/></include>,
            <include refid="toTsVector"><property name="tokens" value="keywords"/></include>,
            <include refid="toTsVector"><property name="tokens" value="md5"/></include>,
            <include refid="toTsVector"><property name="tokens" value="sha1"/></include>,
            <include refid="toTsVector"><property name="tokens" value="sha256"/></include>,
            <include refid="toTsVector"><property name="tokens" value="sha512"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues1"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues2"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues3"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues4"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues5"/></include>,
            comp.created
        FROM ${format}_component comp WHERE component_id = #{componentId}
        -- The WHERE clause above ensures the component still exists
        -- Thereby helping us avoid the need for DELET'ing threads to lock component ids
      ON CONFLICT ON CONSTRAINT pk_search_components
      DO
        UPDATE SET
          last_event_time = #{lastEventTime},
          component_kind = #{componentKind},
          prerelease = #{prerelease},
          uploaders = <include refid="toTsVector"><property name="tokens" value="uploaders"/></include>,
          uploader_ips = <include refid="toTsVector"><property name="tokens" value="uploaderIps"/></include>,
          paths = <include refid="join"><property name="thePaths" value="paths"/></include>,
          tsvector_paths = <include refid="toTsVector"><property name="tokens" value="paths"/></include>,
          keywords = <include refid="toTsVector"><property name="tokens" value="keywords"/></include>,
          md5 = <include refid="toTsVector"><property name="tokens" value="md5"/></include>,
          sha1 = <include refid="toTsVector"><property name="tokens" value="sha1"/></include>,
          sha256 = <include refid="toTsVector"><property name="tokens" value="sha256"/></include>,
          sha512 = <include refid="toTsVector"><property name="tokens" value="sha512"/></include>,
          format_field_values_1 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues1"/></include>,
          format_field_values_2 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues2"/></include>,
          format_field_values_3 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues3"/></include>,
          format_field_values_4 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues4"/></include>,
          format_field_values_5 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues5"/></include>
        WHERE EXISTS(SELECT component_id FROM ${format}_component WHERE component_id = #{componentId})
        -- The EXISTS clause above ensures the component still exists
        -- Thereby helping us avoid the need for DELET'ing threads to lock component ids
  </insert>

  <delete id="delete">
    DELETE
    FROM search_components
    WHERE <include refid="PKMatch"/>
  </delete>

  <delete id="deleteComponentIds">
    DELETE
    FROM search_components
    WHERE repository_id = #{repositoryId}
      AND format = #{format}
      <foreach collection="componentIds" item="componentId" open="AND component_id IN (" separator="," close=")">
        ${componentId}
      </foreach>
  </delete>

  <delete id="deleteAllForRepository">
    WITH toBeDeleted as (
        SELECT component_id
        FROM search_components
        WHERE <include refid="repositoryMatch"/>
    <if test="limit gt 0"> LIMIT ${limit}</if>)
    DELETE
    FROM search_components cs
    WHERE <include refid="repositoryMatch"/>
        AND cs.component_id IN (SELECT td.component_id FROM toBeDeleted td)
  </delete>

  <resultMap id="searchDataMap" type="org.sonatype.nexus.repository.content.search.SearchResultData">
    <id property="componentId" column="component_id" />
    <id property="repositoryId" column="repository_id" />
    <result property="namespace" column="namespace"/>
    <result property="componentName" column="search_component_name"/>
    <result property="version" column="version"/>
    <result property="normalisedVersion" column="normalised_version"/>
    <result property="repositoryName" column="search_repository_name"/>
    <result property="format" column="format"/>
    <result property="created" column="component_created" />
  </resultMap>

  <select id="searchComponents" resultMap="searchDataMap" parameterType="SqlSearchRequest">
    SELECT
        cs.component_id,
        cs.namespace,
        cs.search_component_name,
        cs.version,
        cs.normalised_version,
        cs.search_repository_name,
        cs.format,
        cs.component_created
    FROM search_components cs
    <if test="filterParams != null and filterParams.containsKey('name') and filterParams.containsKey('format')">
      INNER JOIN ${filterParams.format}_component_tag ctg
          ON cs.component_id = ctg.component_id AND cs.format = #{filterParams.format}
      INNER JOIN tag tg ON ctg.tag_id = tg.id
    </if>
    <where>
      <if test="tagToComponentIds != null">
        <foreach collection="tagToComponentIds.entrySet()" index="key" item="value" separator="OR">
          (cs.format = #{key}
          AND cs.component_id IN
          <foreach collection="value" index="idx" item="item" open="(" separator="," close=")">
            ${item}
          </foreach>
          )
        </foreach>
      </if>
      <if test="filter != null">(${filter})</if>
    </where>
    ORDER BY ${sortColumnName} ${sortDirection}
    <if test="sortColumnName != defaultSortColumnName">, ${defaultSortColumnName}</if>
    <if test="sortColumnName != secondDefaultSortColumnName">, ${secondDefaultSortColumnName}</if>
    <if test="limit != null">LIMIT #{limit}</if>
    OFFSET #{offset};
  </select>

  <select id="count" resultType="int">
    SELECT COUNT(cs.component_id)
    FROM search_components cs
    <if test="filterParams != null and filterParams.containsKey('name')">
      INNER JOIN ${filterParams.format}_component_tag ctg
          ON cs.component_id = ctg.component_id AND cs.format = #{filterParams.format}
      INNER JOIN tag tg ON ctg.tag_id = tg.id
    </if>
    <where>
      <if test="filter != null">(${filter})</if>
    </where>
  </select>

  <insert id="saveBatch" parameterType="java.util.List" databaseId="PostgreSQL">
    INSERT INTO search_components(repository_id, component_id, format, namespace, search_component_name, version,
      search_repository_name, tsvector_format, tsvector_namespace, tsvector_search_component_name,
      tsvector_version, tsvector_search_repository_name, component_kind, normalised_version, component_created,
      prerelease, last_event_time, paths, uploaders, uploader_ips, tsvector_paths, keywords, md5, sha1, sha256, sha512, format_field_values_1,
      format_field_values_2, format_field_values_3, format_field_values_4, format_field_values_5) VALUES
    <foreach collection="searchData" separator="," item="item">
      (#{item.repositoryId}, #{item.componentId},  #{item.format}, #{item.namespace},
       #{item.componentName},#{item.version}, #{item.repositoryName},
       to_tsvector('simple', coalesce(#{item.format}, '')), to_tsvector('simple', coalesce(#{item.namespace}, '')),
       to_tsvector('simple', coalesce(#{item.componentName}, '')), to_tsvector('simple', coalesce(#{item.version}, '')),
       to_tsvector('simple', coalesce(#{item.repositoryName}, '')), #{item.componentKind}, #{item.normalisedVersion},
       #{item.componentCreated}, #{item.prerelease}, CURRENT_TIMESTAMP,
      <include refid="join"><property name="thePaths" value="item.paths"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.uploaders"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.uploaderIps"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.paths"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.keywords"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.md5"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.sha1"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.sha256"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.sha512"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues1"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues2"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues3"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues4"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues5"/></include>
       )
    </foreach>
  </insert>

  <sql id="toTsVector" databaseId="PostgreSQL">
    <choose>
      <when test="${tokens}.isEmpty()">null</when>
      <otherwise>
        <foreach collection="${tokens}" separator="||" item="token" open="(" close=")">
          to_tsvector('simple', coalesce(#{token}, ''))
        </foreach>
      </otherwise>
    </choose>
  </sql>

  <sql id="join" databaseId="PostgreSQL">
    <choose>
      <when test="${thePaths}.isEmpty()">null</when>
      <otherwise>
        CONCAT_WS(' ',<foreach collection="${thePaths}" separator=", " item="path">'{' || #{path}::VARCHAR || '}'</foreach>)
      </otherwise>
    </choose>
  </sql>

  <select id="findComponentIdsByTag" resultMap="searchDataMap">
    <foreach collection="formats" index="index" item="format" separator=" UNION ALL ">
      SELECT
          '${format}' as format,
          ct.component_id as component_id
      FROM tag t
          INNER JOIN ${format}_component_tag ct on t.id = ct.tag_id AND t.name = #{tagName}
    </foreach>
      ORDER BY format, component_id
  </select>
</mapper>
