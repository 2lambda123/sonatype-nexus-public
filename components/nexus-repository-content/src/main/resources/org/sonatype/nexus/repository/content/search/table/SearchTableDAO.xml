<?xml version="1.0" encoding="UTF-8" ?>
<!--

    Sonatype Nexus (TM) Open Source Version
    Copyright (c) 2008-present Sonatype, Inc.
    All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.

    This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
    which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.

    Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. "Sonatype" and "Sonatype Nexus" are trademarks
    of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
    Eclipse Foundation. All other trademarks are the property of their respective owners.

-->
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.sonatype.nexus.repository.content.search.table.SearchTableDAO">
  <insert id="createSchema" >
    CREATE TABLE IF NOT EXISTS component_search
    (
      repository_id          INTEGER                  NOT NULL,
      component_id           INTEGER                  NOT NULL,
      format                 VARCHAR                  NOT NULL,
      namespace              VARCHAR                  NOT NULL,
      search_component_name  VARCHAR                  NOT NULL,
      component_kind         VARCHAR                  NOT NULL,
      version                VARCHAR                  NOT NULL,
      component_created      TIMESTAMP WITH TIME ZONE NOT NULL,
      search_repository_name VARCHAR(200)             NOT NULL,
      CONSTRAINT pk_component_search PRIMARY KEY (repository_id, component_id, format)
      );

    -- Columns added after this table was included in a release
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS normalised_version VARCHAR NOT NULL;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS prerelease BOOLEAN NOT NULL DEFAULT false;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS uploader VARCHAR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS uploader_ip VARCHAR;

    CREATE INDEX IF NOT EXISTS idx_component_search_normalised_version ON component_search (normalised_version);
    CREATE INDEX IF NOT EXISTS idx_component_search_namespace ON component_search (namespace);
    CREATE INDEX IF NOT EXISTS idx_component_search_component_name ON component_search (search_component_name);
    CREATE INDEX IF NOT EXISTS idx_component_search_format ON component_search (format);
    CREATE INDEX IF NOT EXISTS idx_component_search_repository_name ON component_search (search_repository_name);
    CREATE INDEX IF NOT EXISTS idx_component_search_prerelease ON component_search (prerelease);
    CREATE INDEX IF NOT EXISTS idx_component_search_uploader ON component_search (uploader);
    CREATE INDEX IF NOT EXISTS idx_component_search_uploader_ip ON component_search (uploader_ip);

    <include refid="createFullTextSearchColumns"/>
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS last_event_time TIMESTAMP WITH TIME ZONE;

  </insert>

  <sql id="createFullTextSearchColumns" databaseId="PostgreSQL">
    -- Only included for upgrades i.e. when upgrading from a version which has the old component_search schema
    ALTER TABLE component_search DROP COLUMN IF EXISTS asset_id;
    ALTER TABLE component_search DROP COLUMN IF EXISTS path;
    ALTER TABLE component_search DROP COLUMN IF EXISTS content_type;
    ALTER TABLE component_search DROP COLUMN IF EXISTS md5;
    ALTER TABLE component_search DROP COLUMN IF EXISTS sha1;
    ALTER TABLE component_search DROP COLUMN IF EXISTS sha256;
    ALTER TABLE component_search DROP COLUMN IF EXISTS sha512;
    ALTER TABLE component_search DROP COLUMN IF EXISTS format_field_1;
    ALTER TABLE component_search DROP COLUMN IF EXISTS format_field_2;
    ALTER TABLE component_search DROP COLUMN IF EXISTS format_field_3;
    ALTER TABLE component_search DROP COLUMN IF EXISTS format_field_4;
    ALTER TABLE component_search DROP COLUMN IF EXISTS format_field_5;
    ALTER TABLE component_search DROP CONSTRAINT IF EXISTS pk_component_search;
    ALTER TABLE component_search DROP COLUMN IF EXISTS uploader;
    ALTER TABLE component_search DROP COLUMN IF EXISTS uploader_ip;

    -- Only included for uprades i.e. when upgrading from a version which has indexes based on the old component_search schema
    DROP INDEX IF EXISTS idx_component_search_path;
    DROP INDEX IF EXISTS idx_component_search_md5;
    DROP INDEX IF EXISTS idx_component_search_sha1;
    DROP INDEX IF EXISTS idx_component_search_sha256;
    DROP INDEX IF EXISTS idx_component_search_sha512;
    DROP INDEX IF EXISTS idx_component_search_format_field_1;
    DROP INDEX IF EXISTS idx_component_search_format_field_2;
    DROP INDEX IF EXISTS idx_component_search_format_field_3;
    DROP INDEX IF EXISTS idx_component_search_format_field_4;
    DROP INDEX IF EXISTS idx_component_search_format_field_5;
    DROP INDEX IF EXISTS idx_component_search_uploader;
    DROP INDEX IF EXISTS idx_component_search_uploader_ip;


    ALTER TABLE component_search ADD CONSTRAINT pk_component_search PRIMARY KEY (repository_id, component_id, format);
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS keywords                         TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS md5                              TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS sha1                             TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS sha256                           TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS sha512                           TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS format_field_values_1            TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS format_field_values_2            TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS format_field_values_3            TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS format_field_values_4            TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS format_field_values_5            TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS uploaders                        TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS uploader_ips                     TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS paths                            VARCHAR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS tsvector_paths                   TSVECTOR;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS tsvector_format                  TSVECTOR NOT NULL;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS tsvector_namespace               TSVECTOR NOT NULL;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS tsvector_search_component_name   TSVECTOR NOT NULL;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS tsvector_version                 TSVECTOR NOT NULL;
    ALTER TABLE component_search ADD COLUMN IF NOT EXISTS tsvector_search_repository_name  TSVECTOR NOT NULL;

    CREATE INDEX IF NOT EXISTS idx_component_search_keywords ON component_search USING GIN (keywords);
    CREATE INDEX IF NOT EXISTS idx_component_search_md5 ON component_search USING GIN (md5);
    CREATE INDEX IF NOT EXISTS idx_component_search_sha1 ON component_search USING GIN (sha1);
    CREATE INDEX IF NOT EXISTS idx_component_search_sha256 ON component_search USING GIN (sha256);
    CREATE INDEX IF NOT EXISTS idx_component_search_sha512 ON component_search USING GIN (sha512);
    CREATE INDEX IF NOT EXISTS idx_component_search_format_field_values_1 ON component_search USING GIN (format_field_values_1);
    CREATE INDEX IF NOT EXISTS idx_component_search_format_field_values_2 ON component_search USING GIN (format_field_values_2);
    CREATE INDEX IF NOT EXISTS idx_component_search_format_field_values_3 ON component_search USING GIN (format_field_values_3);
    CREATE INDEX IF NOT EXISTS idx_component_search_format_field_values_4 ON component_search USING GIN (format_field_values_4);
    CREATE INDEX IF NOT EXISTS idx_component_search_format_field_values_5 ON component_search USING GIN (format_field_values_5);
    CREATE INDEX IF NOT EXISTS idx_component_search_format_uploaders ON component_search USING GIN (uploaders);
    CREATE INDEX IF NOT EXISTS idx_component_search_format_uploader_ips ON component_search USING GIN (uploader_ips);
    CREATE INDEX IF NOT EXISTS idx_component_search_paths ON component_search (paths);
    CREATE INDEX IF NOT EXISTS idx_component_search_tsvector_paths ON component_search USING GIN (tsvector_paths);

    CREATE INDEX IF NOT EXISTS idx_component_search_tsvector_format ON component_search USING GIN (tsvector_format);
    CREATE INDEX IF NOT EXISTS idx_component_search_tsvector_namespace ON component_search USING GIN (tsvector_namespace);
    CREATE INDEX IF NOT EXISTS idx_component_search_tsvector_search_component_name ON component_search USING GIN (tsvector_search_component_name);
    CREATE INDEX IF NOT EXISTS idx_component_search_tsvector_version ON component_search USING GIN (tsvector_version);
    CREATE INDEX IF NOT EXISTS idx_component_search_tsvector_search_repository_name ON component_search USING GIN (tsvector_search_repository_name);
  </sql>

  <sql id = "createFullTextSearchColumns"/>

  <sql id="repositoryMatch">
    repository_id = #{repositoryId}
    AND format = #{format}
  </sql>

  <sql id="componentMatch">
    <include refid="repositoryMatch"/>
    AND component_id = #{componentId}
  </sql>

  <sql id="PKMatch">
    <include refid="componentMatch"/>
  </sql>

  <resultMap id="searchTableData" type="org.sonatype.nexus.repository.content.search.table.SearchTableData">
    <id property="repositoryId" column="repository_id" />
    <id property="componentId" column="component_id" />
    <id property="format" column="format" />
    <result property="namespace" column="namespace"/>
    <result property="componentName" column="search_component_name"/>
    <result property="componentKind" column="component_kind"/>
    <result property="version" column="version"/>
    <result property="normalisedVersion" column="normalised_version"/>
    <result property="componentCreated" column="component_created"/>
    <result property="repositoryName" column="search_repository_name"/>
    <result property="prerelease" column="prerelease"/>
  </resultMap>

  <insert id="save" parameterType="SearchTableData" databaseId="PostgreSQL">

    -- Only insert if the component still exists - we achieve this by using the FROM clause below to check the existence of the component
    -- In a multi node setup, as we can't use distributed cooperation for processing a if one node has deleted all the component records for a given repository in response to a
    -- ContentRepositoryDeleted event, for a  then we don't want a delayed update from another node to re-introduce
    -- any of those records.
      INSERT INTO component_search(repository_id, component_id, format, namespace, search_component_name, version,
          search_repository_name, tsvector_format, tsvector_namespace, tsvector_search_component_name,
          tsvector_version, tsvector_search_repository_name, component_kind, normalised_version, prerelease, last_event_time,
          paths, uploaders, uploader_ips, tsvector_paths, keywords, md5, sha1, sha256, sha512, format_field_values_1, format_field_values_2,
          format_field_values_3, format_field_values_4, format_field_values_5, component_created)
        SELECT
           #{repositoryId}, #{componentId}, #{format}, #{namespace}, #{componentName}, #{version}, #{repositoryName},
            to_tsvector('simple', coalesce(#{format}, '')), to_tsvector('simple', coalesce(#{namespace}, '')),
            to_tsvector('simple', coalesce(#{componentName}, '')), to_tsvector('simple', coalesce(#{version}, '')),
            to_tsvector('simple', coalesce(#{repositoryName}, '')),
            #{componentKind}, #{normalisedVersion}, #{prerelease}, #{lastEventTime},
            <include refid="join"><property name="thePaths" value="paths"/></include>,
            <include refid="toTsVector"><property name="tokens" value="uploaders"/></include>,
            <include refid="toTsVector"><property name="tokens" value="uploaderIps"/></include>,
            <include refid="toTsVector"><property name="tokens" value="paths"/></include>,
            <include refid="toTsVector"><property name="tokens" value="keywords"/></include>,
            <include refid="toTsVector"><property name="tokens" value="md5"/></include>,
            <include refid="toTsVector"><property name="tokens" value="sha1"/></include>,
            <include refid="toTsVector"><property name="tokens" value="sha256"/></include>,
            <include refid="toTsVector"><property name="tokens" value="sha512"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues1"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues2"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues3"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues4"/></include>,
            <include refid="toTsVector"><property name="tokens" value="formatFieldValues5"/></include>,
            comp.created
        FROM ${format}_component comp WHERE component_id = #{componentId}
        -- The WHERE clause above ensures the component still exists
        -- Thereby helping us avoid the need for DELET'ing threads to lock component ids
      ON CONFLICT ON CONSTRAINT pk_component_search
      DO
        UPDATE SET
          last_event_time = #{lastEventTime},
          component_kind = #{componentKind},
          prerelease = #{prerelease},
          uploaders = <include refid="toTsVector"><property name="tokens" value="uploaders"/></include>,
          uploader_ips = <include refid="toTsVector"><property name="tokens" value="uploaderIps"/></include>,
          paths = <include refid="join"><property name="thePaths" value="paths"/></include>,
          tsvector_paths = <include refid="toTsVector"><property name="tokens" value="paths"/></include>,
          keywords = <include refid="toTsVector"><property name="tokens" value="keywords"/></include>,
          md5 = <include refid="toTsVector"><property name="tokens" value="md5"/></include>,
          sha1 = <include refid="toTsVector"><property name="tokens" value="sha1"/></include>,
          sha256 = <include refid="toTsVector"><property name="tokens" value="sha256"/></include>,
          sha512 = <include refid="toTsVector"><property name="tokens" value="sha512"/></include>,
          format_field_values_1 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues1"/></include>,
          format_field_values_2 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues2"/></include>,
          format_field_values_3 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues3"/></include>,
          format_field_values_4 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues4"/></include>,
          format_field_values_5 = <include refid="toTsVector"><property name="tokens" value="formatFieldValues5"/></include>
        WHERE EXISTS(SELECT component_id FROM ${format}_component WHERE component_id = #{componentId})
        -- The EXISTS clause above ensures the component still exists
        -- Thereby helping us avoid the need for DELET'ing threads to lock component ids
  </insert>

  <delete id="delete">
    DELETE
    FROM component_search
    WHERE <include refid="PKMatch"/>
  </delete>

  <delete id="deleteComponentIds">
    DELETE
    FROM component_search
    WHERE repository_id = #{repositoryId}
      AND format = #{format}
      <foreach collection="componentIds" item="componentId" open="AND component_id IN (" separator="," close=")">
        ${componentId}
      </foreach>
  </delete>

  <delete id="deleteAllForRepository">
    WITH toBeDeleted as (
        SELECT component_id
        FROM component_search
        WHERE <include refid="repositoryMatch"/>
    <if test="limit gt 0"> LIMIT ${limit}</if>)
    DELETE
    FROM component_search cs
    WHERE <include refid="repositoryMatch"/>
        AND cs.component_id IN (SELECT td.component_id FROM toBeDeleted td)
  </delete>

  <resultMap id="searchDataMap" type="org.sonatype.nexus.repository.content.search.SearchResultData">
    <id property="componentId" column="component_id" />
    <id property="repositoryId" column="repository_id" />
    <result property="namespace" column="namespace"/>
    <result property="componentName" column="search_component_name"/>
    <result property="version" column="version"/>
    <result property="normalisedVersion" column="normalised_version"/>
    <result property="repositoryName" column="search_repository_name"/>
    <result property="format" column="format"/>
    <result property="created" column="component_created" />
  </resultMap>

  <select id="searchComponents" resultMap="searchDataMap" parameterType="SqlSearchRequest">
    SELECT
        cs.component_id,
        cs.namespace,
        cs.search_component_name,
        cs.version,
        cs.normalised_version,
        cs.search_repository_name,
        cs.format,
        cs.component_created
    FROM component_search cs
    <if test="filterParams != null and filterParams.containsKey('name') and filterParams.containsKey('format')">
      INNER JOIN ${filterParams.format}_component_tag ctg
          ON cs.component_id = ctg.component_id AND cs.format = #{filterParams.format}
      INNER JOIN tag tg ON ctg.tag_id = tg.id
    </if>
    <where>
      <if test="tagToComponentIds != null">
        <foreach collection="tagToComponentIds.entrySet()" index="key" item="value" separator="OR">
          (cs.format = #{key}
          AND cs.component_id IN
          <foreach collection="value" index="idx" item="item" open="(" separator="," close=")">
            ${item}
          </foreach>
          )
        </foreach>
      </if>
      <if test="filter != null">(${filter})</if>
    </where>
    ORDER BY ${sortColumnName} ${sortDirection}
    <if test="sortColumnName != defaultSortColumnName">, ${defaultSortColumnName}</if>
    <if test="sortColumnName != secondDefaultSortColumnName">, ${secondDefaultSortColumnName}</if>
    <if test="limit != null">LIMIT #{limit}</if>
    OFFSET #{offset};
  </select>

  <select id="count" resultType="int">
    SELECT COUNT(cs.component_id)
    FROM component_search cs
    <if test="filterParams != null and filterParams.containsKey('name')">
      INNER JOIN ${filterParams.format}_component_tag ctg
          ON cs.component_id = ctg.component_id AND cs.format = #{filterParams.format}
      INNER JOIN tag tg ON ctg.tag_id = tg.id
    </if>
    <where>
      <if test="filter != null">(${filter})</if>
    </where>
  </select>

  <insert id="saveBatch" parameterType="java.util.List" databaseId="PostgreSQL">
    INSERT INTO component_search(repository_id, component_id, format, namespace, search_component_name, version,
      search_repository_name, tsvector_format, tsvector_namespace, tsvector_search_component_name,
      tsvector_version, tsvector_search_repository_name, component_kind, normalised_version, component_created,
      prerelease, last_event_time, paths, uploaders, uploader_ips, tsvector_paths, keywords, md5, sha1, sha256, sha512, format_field_values_1,
      format_field_values_2, format_field_values_3, format_field_values_4, format_field_values_5) VALUES
    <foreach collection="searchData" separator="," item="item">
      (#{item.repositoryId}, #{item.componentId},  #{item.format}, #{item.namespace},
       #{item.componentName},#{item.version}, #{item.repositoryName},
       to_tsvector('simple', coalesce(#{item.format}, '')), to_tsvector('simple', coalesce(#{item.namespace}, '')),
       to_tsvector('simple', coalesce(#{item.componentName}, '')), to_tsvector('simple', coalesce(#{item.version}, '')),
       to_tsvector('simple', coalesce(#{item.repositoryName}, '')), #{item.componentKind}, #{item.normalisedVersion},
       #{item.componentCreated}, #{item.prerelease}, CURRENT_TIMESTAMP,
      <include refid="join"><property name="thePaths" value="item.paths"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.uploaders"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.uploaderIps"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.paths"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.keywords"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.md5"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.sha1"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.sha256"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.sha512"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues1"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues2"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues3"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues4"/></include>,
      <include refid="toTsVector"><property name="tokens" value="item.formatFieldValues5"/></include>
       )
    </foreach>
  </insert>

  <sql id="toTsVector" databaseId="PostgreSQL">
    <choose>
      <when test="${tokens}.isEmpty()">null</when>
      <otherwise>
        <foreach collection="${tokens}" separator="||" item="token" open="(" close=")">
          to_tsvector('simple', coalesce(#{token}, ''))
        </foreach>
      </otherwise>
    </choose>
  </sql>

  <sql id="join" databaseId="PostgreSQL">
    <choose>
      <when test="${thePaths}.isEmpty()">null</when>
      <otherwise>
        CONCAT_WS(' ',<foreach collection="${thePaths}" separator=", " item="path">'{' || #{path}::VARCHAR || '}'</foreach>)
      </otherwise>
    </choose>
  </sql>

  <select id="findComponentIdsByTag" resultMap="searchDataMap">
    <foreach collection="formats" index="index" item="format" separator=" UNION ALL ">
      SELECT
          '${format}' as format,
          ct.component_id as component_id
      FROM tag t
          INNER JOIN ${format}_component_tag ct on t.id = ct.tag_id AND t.name = #{tagName}
    </foreach>
      ORDER BY format, component_id
  </select>
</mapper>
